<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Spring循环依赖报错问题分析 | Knowledge+Technology</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring循环依赖报错问题分析</h1><a id="logo" href="/.">Knowledge+Technology</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring循环依赖报错问题分析</h1><div class="post-meta">Jan 12, 2018<span> | </span><span class="category"><a href="/categories/工具与经验/">工具与经验</a></span></div><div class="post-content"><p>一、前言  </p>
<p>=======</p>
<p>Spring工程在本地环境部署没问题，在预发布环境报了一个与循环依赖有关的错误。经过排查发现，报错的直接原因是不同环境bean的初始化顺序不同，根本原因是Spring二次代理问题。</p>
<p>二、问题分析  </p>
<p>=========</p>
<p>报错如下:<br>Bean with name ‘beanName’ has been injected into other beans [actualDependentBeans] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using ‘getBeanNamesOfType’ with the ‘allowEagerInit’ flag turned off, for example.<br>乍看之下，似乎就是由循环依赖引起的问题。事实上，通过消除应用中的循环依赖，报错也确实没有了。然而，Spring是支持循环依赖的，循环依赖不应该是问题的根本原因。</p>
<p>1、类间依赖关系分析  </p>
<hr>
<p>既然是与循环依赖有关的错误，那么先把循环依赖关系列出来。这个循环依赖涉及4个类，类间依赖关系如下：<br><img src="576349aa-c921-432a-b0b8-0d802feda0bf.png" alt=""><br>从上图可以看出4个类之间存在复杂的循环依赖关系。然而，在复杂的工程之中，循环依赖关系并不少见。  </p>
<p>2、通过Spring源码定位问题  </p>
<hr>
<p>上述报错的位置是AbstractAutowireCapableBeanFactory的doCreateBean方法。<br><img src="f1a3f423-3bf4-4b16-882c-43a9e2fcc86d.png" alt=""><br>从上面的代码可以推断，上述报错出现需要满足如下条件：<br>1、存在循环依赖（明显存在）<br>2、initializeBean 方法返回了一个新对象<br>因此问题在于，initializeBean方法的用途，以及为什么返回了一个新的对象。  </p>
<h3 id="2-1-initializedBean方法分析"><a href="#2-1-initializedBean方法分析" class="headerlink" title="2.1 initializedBean方法分析"></a>2.1 initializedBean方法分析</h3><p>initializeBean方法的注解是 Initialize the given bean instance, applying factory callbacks as well as init methods and bean post processors<br>initializeBean方法主要完成：<br>步骤1、applyBeanPostProcessorsBeforeInitialization<br>步骤2、invokeInitMethods 调用bean的init-method<br>步骤3、applyBeanPostProcessorsAfterInitialization<br>步骤1和3都是对BeanPostProcessor的调用。BeanPostProcessor可能包括某些ProxyCreator，ProxyCreator 可能对原始bean做代理，返回一个新的代理类。<br>即是说，initializeBean方法返回一个新的代理对象是可能且合理的，但是从上文的分析知道，在存在循环依赖的情况下只要initializeBean方法返回了一个新对象就会报错。<br>那么Spring是如何处理循环依赖情况下代理类的生成的呢？  </p>
<h3 id="2-2-存在循环依赖情况下代理类的生成分析"><a href="#2-2-存在循环依赖情况下代理类的生成分析" class="headerlink" title="2.2 存在循环依赖情况下代理类的生成分析"></a>2.2 存在循环依赖情况下代理类的生成分析</h3><p>下面是用于测试循环依赖情况下代理类生成的代码：<br><img src="5ac9396f-aa15-4e90-869b-7a3f0c8aabe3.png" alt=""><br>上面的代码并不会报错。  </p>
<p>下面是对存在循环依赖情况下，classA和classB的初始化过程的分析。<br><img src="3b5ee541-7df6-4837-85d4-4fbdda5e954b.png" alt=""><br>通过上面的分析可以知道，在存在循环依赖的情况下，由于classB初始化过程中已经对classA生成了代理类，所以在initiliazeBean方法中并不会返回新的代理类，因为不会报错。<br>问题分析至此，知道对于存在循环依赖和代理的情况，Spring一般也是能够正确处理的。  </p>
<h3 id="2-3-从Spring-debug日志切入-定位问题原因"><a href="#2-3-从Spring-debug日志切入-定位问题原因" class="headerlink" title="2.3 从Spring debug日志切入 定位问题原因"></a>2.3 从Spring debug日志切入 定位问题原因</h3><p>由于本地环境部署工程不会报错，而预发布环境又无法调试。要获得更详细的信息，只能够通过Spring的debug日志获得。<br>拿到本地和预发布环境的Spring debug日志之后，把所有跟tradeService、tradeRefundTransferService、orderService、payTransactionService相关的日志都提取出来。<br>经过分析发现，本地与预发布环境，在bean的初始化顺序上存在差异。<br>本地环境bean的初始化顺序如下：<br><img src="b1ddbdd2-ed58-4d24-97ce-46305515409a.png" alt=""><br>预发布环境bean的初始化顺序如下：<br><img src="475c2fec-62dc-4497-9f28-49a11be2907c.png" alt=""><br>注意到，预发布环境有两个ProxyCreator AnnotationAwareAspectJAutoProxyCreator和DefaultAdvisorAutoProxyCreator先后对tradeRefundTransferService做了代理。<br>DefaultAdvisorAutoProxyCreator对tradeRefundTransferService做了代理之后，将会导致其他bean引用到的tradeRefundTransferService并不是最终版本，从而导致报错。<br>因此问题的关键在于，为什么在预发布环境DefaultAdvisorAutoProxyCreator会对tradeRefundTransferService又做了一次代理，而本地环境却不会呢？  </p>
<h3 id="2-4-最终分析"><a href="#2-4-最终分析" class="headerlink" title="2.4 最终分析"></a>2.4 最终分析</h3><p>通过Spring debug日志 发现问题是由bean的初始化顺序不同引起的。在本地通过使用@dependsOn annotation 使本地环境的bean初始化顺序与预发布环境相同之后，果然复现了预发布环境的错误。  </p>
<p>0、关于ProxyCreator和cacheKey的简单说明<br>每个ProxyCreator有一个名为earlyProxyReferences属性，这个属性是Set类型，用来保存通过这个ProxyCreator生成过代理类的bean的key值。 比如，如果通过调用ProxyCreatorA的getEarlyBeanReference() 方法生成了一个classA的代理类，那么就会将classA对应的cacheKey放到ProxyCreator的earlyProxyReferences中。 cacheKey的生成规则是className_beanName。当下一次再调用ProxyCreatorA的getEarlyBeanReference方法来获取classA的代理类时，检查发现ProxyCreatorA的earlyProxyReferences已经包含了classA对应的cacheKey，就会直接把上一次调用生成的代理类返回，不会重新生成代理类。 值得注意的是，classA和classA的代理类所对应的cacheKey是不同的。  </p>
<p>1、预发布环境二次代理过程<br>下文中统一把tradeRefundTransferService记为serviceA，tradeRefundTransferService的代理类记为serverA-proxy，AnnotationAwareAspectJAutoProxyCreator 记为proxyCreator1，DefaultAdvisorAutoProxyCreator记为proxyCreator2。  </p>
<p>(1) 第一次生成代理<br>第一次对serviceA生成代理类是在AbstractAutowiredCapableBeanFactory的getEarlyBeanReference方法中。 对应于下图中标注的位置：<br><img src="e2bea298-99f1-4e1f-8a5a-b85f8428456e.png" alt=""><br>在serviceA的初始化过程中，当其他类需要引用到serviceA，但是此时serviceA还没有生成final version（由循环依赖造成），此时为了避免其他类引用到非final version的serviceA，在把serviceA作为属性设置给其他类之前，就需要生成serviceA的代理类serverA-proxy。<br>AbstractAutowiredCapableBeanFactory的getEarlyBeanReference做的就是这个事情。在这个方法中，先把serviceA的instance拿出来，然后调用各个BeanPostProcessor进行处理，最后把经过处理之后的final version的serviceA返回<br><img src="017b1161-8e45-4304-ad2f-02a6f291638c.png" alt=""><br>在该方法中，proxyCreator1和proxyCreator2会依次对serviceA进行处理。  </p>
<p>proxyCreator1的getEarlyBeanReference方法会首先被调用<br>在这个方法中，会生成serviceA的cacheKey，记为key1，把key1加入到proxyA的earlyProxyReferences中，并生成serviceA的代理类 serviceA-proxy。  </p>
<p>随后proxyCreator2的getEarlyBeanReference()方法被调用<br>由于serviceA已经被代理过，所以此时得到另一个cacheKey，记为key2，key2 会被加入到proxyCreator2 的earlyProxyReferences中<br>值得注意的是，此时proxyCreator2不会对serviceA再做代理，因为传给proxyCreator2的已经是一个代理类。  </p>
<p>(2) 第二次生成代理<br>第二次对serviceA生成代理类的时机是在AbstractAutowireCapableBeanFactory的initiliazeBean方法中<br>对应于下图中标注的位置：<br><img src="86b560ec-97e2-4041-bde1-17b0dc27a35c.png" alt=""><br>如上文所述，这个方法主要是对bean做后置处理。 在这个方法中，同样会依次调用BeanPostProcessor对serviceA进行处理，和上文的getEarlyBeanReference方法类似。<br>需要注意的是，此时传给initiliazeBean 方法的，并不是serviceA的代理类serviceA-proxy，而是serviceA。<br>首先是proxyCreator1对serviceA进行处理，依次调用postProcessBeforeInitialization和postProcessAfterInitialization方法。<br>proxyCreator1的postProcessAfterInitialization方法：<br><img src="fa89107b-8ade-4d08-89c0-f70ce0846b3d.png" alt=""><br>在这个方法中，传入的是serviceA的instance，得到的cacheKey是key1，proxyCreator1 在earlyProxyReferences已经有key1，所以不会再做代理，直接把serviceA返回。<br>然后是proxyCreator2对serviceA进行处理。<br>在proxyCreator2的postProcessAfterInitialization方法中，传入的还是serviceA，因为上一步proxyCreator1发现serviceA已经代理过，所以把serviceA原样返回了。 接下来就是最关键的一步了。 proxyCreator2在自己的earlyProxyReferences 没有找到key1，因为如上所述，proxyCreator2的earlyProxyReferences 中存的是key2<br>然后proxyCreator2对serviceA又做了一次代理，于是就出现了proxyCreator1和proxyCreator2先后对tradeRefundTransferService做了代理的情况。  </p>
<p>2、本地环境不会发生二次代理过程<br>本地环境与预发布环境的不同点在于，在本地环境，由于tradeRefundTransferService是最后初始化的，避免了被做两次代理，所以不会报错。</p>
<h3 id="2-5-解决方案"><a href="#2-5-解决方案" class="headerlink" title="2.5 解决方案"></a>2.5 解决方案</h3><p>在工程中，有两个配置文件配置了代理。<br>第一个地方的配置如下：<br><code>&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;/&gt;</code><br>第二个地方的配置如下：<br><code>&lt;bean id=&quot;aspectJPointcutAdvisor&quot; class=&quot;org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor&quot;&gt; &lt;property name=&quot;expression&quot; value=&quot;@annotation(com.XXX.XXX.aspect.TransactionAdvice.Transaction)&quot;/&gt; &lt;property name=&quot;advice&quot; ref=&quot;transactionAdvice&quot;/&gt; &lt;/bean&gt;</code><br>把第一个地方的配置注释掉之后可以解决上述循环依赖导致的错误。<br>如果没有必要，不要使用低级别API，比如不要自己手动创建AutoProxyCreator。使用<code>&lt;aop:config proxy-target-class=&quot;true&quot;/&gt;</code>或<code>&lt;aop:aspectj-autoproxy/&gt;</code>的方式进行配置。</p>
</div><div class="tags"><a href="/tags/Spring/">Spring</a><a href="/tags/AOP/">AOP</a></div><div class="post-nav"><a href="/2018/01/12/配置托管演进与优化/" class="pre">配置托管演进与优化</a><a href="/2018/01/12/基于缓存实现分布式锁/" class="next">基于缓存实现分布式锁</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具与经验/">工具与经验</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/regex/" style="font-size: 15px;">regex</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/分布式配置/" style="font-size: 15px;">分布式配置</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/分布式锁/" style="font-size: 15px;">分布式锁</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/12/配置托管演进与优化/">配置托管演进与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/12/Spring循环依赖报错问题分析/">Spring循环依赖报错问题分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/12/基于缓存实现分布式锁/">基于缓存实现分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/26/基于hexo搭建github博客/">github博客搭建指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/21/DFA_VS_NFA/">正则表达式匹配原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/01/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Knowledge+Technology.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>